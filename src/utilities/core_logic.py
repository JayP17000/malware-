"""
    Date created:   12/01/2023
    Date edited:    12/02/2023
    Sub-module:     core_logic.py
    Remarks:        This python Scrip contains all the functionalities needed to
                    execute RUNYara
"""

import os
import sys
import time
import yara
import hashlib

import pandas as pd
import src.frames.py.gui_main as mn
import src.frames.py.gui_results as rs

from pandas import ExcelWriter
from datetime import datetime

from PySide6.QtGui import QImage, QPixmap, Qt, QMovie, QShortcut, QKeySequence, QIcon
from PySide6.QtCore import QObject, Signal, QRunnable, QThreadPool
from PySide6.QtWidgets import QApplication, QMainWindow, QFileDialog, QLabel, QTableWidgetItem, QMessageBox

# Global Variables
SELECTED_DIRECTORY = None
SELECTED_FILE = None
RULE_PATH = None
RES_PATH = None
MAIN_WINDOW = None


class ui_main(QMainWindow, mn.Ui_MainWindow):
    """
        Remarks: Main window frame declaration and definition.
    """

    def __init__(self):
        """
            Remarks: Class definition
        """

        super().__init__()

        self.setupUi(self)
        self.RESULT_WINDOW = ui_results()
        self._connect_signals_to_slots()
        self._retrieve_paths()
        self.threadpool = QThreadPool()

        # Update as version gets updated.
        self.setWindowTitle("RUNYara - Ver. 0.0.1")

        self.loading_bar = QLabel()
        self._load_images_icons()
        self._animated_progress_bar()
        self.movie = None

        self.lblStatusbar = QLabel()
        self.statusbar.addPermanentWidget(self.lblStatusbar)

    def _retrieve_paths(self):
        """
            Remarks: Retrieves through dynamic path the yara rules stored in the program and the resources folder
        """
        global RULE_PATH, RES_PATH
        current_path = os.path.abspath(__file__)
        dir_path = os.path.dirname(current_path)
        RULE_PATH = os.path.join(dir_path, 'yara_rules')
        # print(str(RULE_PATH))

        dir_path2 = os.path.dirname(dir_path)
        RES_PATH = os.path.join(dir_path2, 'res')
        # print(str(RES_PATH))

    def _load_images_icons(self):
        """
            Remarks: Loads the main image into the Main Window form.
        """
        image_path = os.path.join(RES_PATH, 'RUNYara.png')
        qimage = QImage(image_path)
        label = QLabel()

        qpixmap = QPixmap.fromImage(qimage)

        scaled_pixmap = qpixmap.scaled(label.size(),
                                       Qt.AspectRatioMode.KeepAspectRatio,
                                       Qt.TransformationMode.SmoothTransformation)

        # Set the scaled pixmap to the QLabel.
        label.setPixmap(scaled_pixmap)
        label.setAlignment(Qt.AlignCenter)
        label.setScaledContents(True)
        self.lyQImage.addWidget(label)

        # Set the icons into the frames.
        icon = QIcon(os.path.join(RES_PATH, '16x16.ico'))
        self.setWindowIcon(icon)
        self.RESULT_WINDOW.setWindowIcon(icon)

    def _animated_progress_bar(self):
        """
            Remarks: Loads an animated gif from the resources file.
        """
        gif_path = os.path.join(RES_PATH, 'loading_bar.gif')
        self.movie = QMovie(gif_path)

        self.loading_bar.setMovie(self.movie)
        self.loading_bar.setAlignment(Qt.AlignCenter)  # Center the movie within the label
        self.loading_bar.setScaledContents(True)

        self.lyLoading_bar.addWidget(self.loading_bar)
        self.loading_bar.hide()
        self.movie.start()

    def hide_lb(self):
        """
            Remarks: Hides the loading bar gif from the frame.
        """
        self.loading_bar.hide()

    def show_lb(self):
        """
            Remarks: Shows/displays the loading bar gif on the frame.
        """
        self.loading_bar.show()

    def _connect_signals_to_slots(self):
        """
            Remarks: Connects all the interactive elements of the GUI to the methods of the class(es)
        """
        # Results Triggers
        # Button "Show" trigger event.
        self.btnShow.clicked.connect(self.RESULT_WINDOW.display_results_window)
        shortcut_show = QShortcut(QKeySequence('Ctrl+R'), self)
        shortcut_show.activated.connect(self.RESULT_WINDOW.display_results_window)

        # Button "Save" trigger event.
        self.actionSave.triggered.connect(self.RESULT_WINDOW.export_to_csv)
        shortcut_save = QShortcut(QKeySequence('Ctrl+S'), self)
        shortcut_save.activated.connect(self.RESULT_WINDOW.export_to_csv)

        # Directory Triggers
        # Button "Open" trigger event.
        self.btnOpen.clicked.connect(self._get_directory_path)
        self.actionOpen.triggered.connect(self._get_directory_path)
        shortcut_open = QShortcut(QKeySequence('Ctrl+O'), self)
        shortcut_open.activated.connect(self._get_directory_path)

        # Scan Triggers
        # Button "Start" trigger event.
        self.btnStart.clicked.connect(self._start_scan)
        shortcut_scan = QShortcut(QKeySequence('Ctrl+A'), self)
        shortcut_scan.activated.connect(self._start_scan)

    def _get_directory_path(self):
        self.update_lblStatusBar("Opening File...")
        """
            Remarks: Allows the user to open a directory.
        """
        # options = QFileDialog.options()
        global SELECTED_DIRECTORY
        SELECTED_DIRECTORY = QFileDialog.getExistingDirectory(
            None,
            "Select a Directory",
            "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        if SELECTED_DIRECTORY:
            # print("Current Directory: ", CURRENT_PATH)
            self.lblPathCont.setText(SELECTED_DIRECTORY)

    def _start_scan(self):
        """
            Remarks: Creates a new thread to run the yara scan on. Allowing the main program to keep running.
        """
        # Define a new Search Worker
        worker = Search_Worker()

        # Connect the retrieved signals to the update methods
        worker.signals.update_current_file.connect(self._update_lblCurrentFileCont)
        worker.signals.update_current_directory.connect(self._update_lblCurrentDirectoryCont)
        worker.signals.update_scanned_files.connect(self._update_lblScannedFilesCont)
        worker.signals.update_scanned_directories.connect(self._update_lblScannedDirectoryCont)
        worker.signals.update_threat_count.connect(self._update_lblThreatCountCont)

        # Add the worker into the threadpool
        self.threadpool.start(worker)

        # Call worker's function with YARA rules path and selected directory
        worker.run_yara(RULE_PATH, SELECTED_DIRECTORY)

    def closeEvent(self, event):
        """
            Remarks: extends the closeEvent method allowing it to also close the RESULT_WINDOW.
        """
        self.RESULT_WINDOW.close()
        event.accept()

    def _update_lblCurrentFileCont(self, filename):
        self.lblCurrentFileCont.setText(str(filename))

    def _update_lblCurrentDirectoryCont(self, directory):
        self.lblCurrentDirectoryCont.setText(str(directory))

    def _update_lblScannedFilesCont(self, count):
        self.lblScannedFilesCont.setText(str(count))

    def _update_lblScannedDirectoryCont(self, count):
        self.lblScannedDirectoriesCont.setText(str(count))

    def _update_lblThreatCountCont(self, count):
        self.lblThreatsDetectedCont.setText(str(count))

    def update_lblStatusBar(self, string):
        self.lblStatusbar.setText(str(string))


class WorkerSignals(QObject):
    """
       Remarks: Defines the Signals to be transmitted between search worker and gui_main.
    """
    update_current_file = Signal(str)
    update_current_directory = Signal(str)
    update_scanned_files = Signal(int)
    update_scanned_directories = Signal(int)
    update_threat_count = Signal(int)


class Search_Worker(QRunnable):
    """
        Remarks: This class defines an object QRunnable to run alongside the main gui.
    """

    def __init__(self):
        super().__init__()
        self.signals = WorkerSignals()
        self._reset_counts()

    def run_yara(self, rules_path, target_directory):
        """
            Remarks: Handles the compilation of the yara rules, and the scanning for threats on a current directory
        """
        self._reset_counts()

        # List all files in the directory
        files = os.listdir(rules_path)

        # Filter .yar files from the list of files
        yara_files = [os.path.join(rules_path, file) for file in files if file.endswith('.yar')]

        # Compile each YARA file
        rules = {}
        for yara_file in yara_files:
            try:
                compiled_rule = yara.compile(yara_file)
                # Extracting the filename without extension as the rule name
                rule_name = os.path.splitext(os.path.basename(yara_file))[0]
                rules[rule_name] = compiled_rule
            except yara.Error as e:
                print(f"Error compiling {yara_file}: {e}")

        # Iterate through the folders and sub-folders of the target directory
        file_path = None

        # Entry to be stored
        entry = {
            "filename": "",
            "flag": "",
            "rules_found": "",
            "scan_date": "",
            "scan_time": "",
            "MD5": "",
            "SHA256": "",
            "location": ""
        }

        # Log the current date.
        current_date = datetime.now()
        f_date = current_date.strftime("%m/%d/%y")
        entry["scan_date"] = f_date

        # Log start of scan time
        st_time = time.time()
        self.start_time = time.strftime("%H:%M:%S", time.localtime(st_time))

        # Display the loading gif.
        MAIN_WINDOW.show_lb()
        MAIN_WINDOW.RESULT_WINDOW.clear_table()

        for root, dirs, files in os.walk(target_directory):
            self.signals.update_current_directory.emit(str(root))
            self.directory_count += 1
            self.signals.update_scanned_directories.emit(self.directory_count)

            for filename in files:
                # Emit signal to display the current file
                # FIXME: Not the best implementation as it could lead to undefined states.
                QApplication.processEvents()

                self.signals.update_current_file.emit(str(filename))
                self.file_count += 1
                self.signals.update_scanned_files.emit(self.file_count)

                # Combine the file name with the root folder name
                file_path = os.path.join(root, filename)

                # Calculate MD5 & SHA256
                try:
                    hashes = self.calculate_hashes(file_path)
                    entry["MD5"] = hashes["MD5"]
                    entry["SHA256"] = hashes["SHA256"]
                except TypeError as te:
                    print(te)

                # Check if the item is a file (not a directory)
                if os.path.isfile(file_path):
                    with open(file_path, 'rb') as f:
                        file_content = f.read()
                        entry["filename"] = str(filename)
                        entry["location"] = str(file_path)
                    # Match the rules against the file content

                    local_threat_count = 0
                    rules_found = []
                    for rule in rules.values():
                        matches = rule.match(data=file_content)

                        # Print the results
                        if matches:
                            # print(f"Malicious indicators found in {filename}:")
                            self.threat_count += 1
                            self.signals.update_threat_count.emit(self.threat_count)
                            for match in matches:
                                # Increase thread_count depending on ho many rules have been detected.
                                local_threat_count += 1
                                rules_found.append(str(match))

                        # Calculate the time a file was scanned.
                        current_time = time.time()
                        scanned_time = time.strftime("%H:%M:%S", time.gmtime(current_time - st_time))
                        entry["scan_time"] = str(scanned_time)

                        if local_threat_count > 0:
                            entry["flag"] = str("THREAT")
                            entry["rules_found"] = str(rules_found)
                        else:
                            entry["flag"] = str("SAFE")
                            entry["rules_found"] = str("No match found.")

                            # Display a single entry.
                            # print(entry)

                    # Add entry to table for display
                    MAIN_WINDOW.RESULT_WINDOW.add_entry_to_table(entry)

        # Log end of scan time.
        MAIN_WINDOW.hide_lb()
        en_time = time.time()
        self.end_time = time.strftime("%H:%M:%S", time.localtime(en_time))
        self.scan_duration = time.strftime("%H:%M:%S", time.gmtime(en_time - st_time))
        # st_time = time.strftime("%H:%M:%S", self.start_time)
        # print(f"Start Time = {self.start_time}, End time = {self.end_time}, Elapsed Time = {self.scan_duration}")

    def _reset_counts(self):
        """
            Remarks: Resets the file and the directory counters.
        """
        self.file_count = 0
        self.directory_count = 0
        self.threat_count = 0
        self.start_time = 0
        self.end_time = 0
        self.scan_duration = 0

        self.signals.update_scanned_files.emit(self.file_count)
        self.signals.update_scanned_directories.emit(self.directory_count)
        self.signals.update_threat_count.emit(self.threat_count)

    def calculate_hashes(self, file_path):
        """
            Calculate the MD5 and SHA256 from a file.
        """
        try:
            with open(file_path, "rb") as file:
                md5_hash = hashlib.md5()
                sha256_hash = hashlib.sha256()
                # Read the file in chunks to handle large files efficiently
                for chunk in iter(lambda: file.read(4096), b""):
                    md5_hash.update(chunk)
                    sha256_hash.update(chunk)
            return {
                "MD5": md5_hash.hexdigest(),
                "SHA256": sha256_hash.hexdigest()
            }
        except FileNotFoundError:
            return "File not found"
        except PermissionError:
            return "Permission denied"
        except Exception as e:
            return f"Error: {e}"


class ui_results(QMainWindow, rs.Ui_MainWindow):
    """
        Remarks: Class definition.
    """

    def __init__(self):
        """
            Remarks: Results window frame declaration and definition.
        """
        super().__init__()
        self.setupUi(self)
        self.row_Count = None
        self.connect_signals_to_slots()

    def connect_signals_to_slots(self):
        """
            Remarks: connects the signals(triggers) to the slots(widgets).
        """
        # Shortcut_save Triggers
        shortcut_save = QShortcut(QKeySequence('Ctrl+S'), self)
        shortcut_save.activated.connect(self.export_to_csv)

        # Shortcut_clear Triggers
        shortcut_clear = QShortcut(QKeySequence('Ctrl+C'), self)
        shortcut_clear.activated.connect(self.clear_table)

    def display_results_window(self):
        """
            Remarks: Displays the result window.
        """
        self.show()

    def clear_table(self):
        """
            Remarks: This method clears the current table.
        """
        self.tbResults.setRowCount(0)  # Clears all rows in the table

    def export_to_csv(self):
        """
            Remarks: This method adds the current participant values into the metrics dataframe
        """
        table = self.tbResults
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(None, "Save CSV File", "", "Excel Files (*.xlsx);;All Files (*)",
                                                   options=options)
        if file_path:
            data = []
            headers = [table.horizontalHeaderItem(i).text() for i in range(table.columnCount())]
            for row in range(table.rowCount()):
                row_data = []
                for column in range(table.columnCount()):
                    item = table.item(row, column)
                    if item is not None:
                        row_data.append(item.text())
                    else:
                        row_data.append('')
                data.append(row_data)

            df = pd.DataFrame(data, columns=headers)

            # Export to Excel
            with ExcelWriter(file_path, engine='xlsxwriter') as writer:
                df.to_excel(excel_writer=writer, index=False, sheet_name="Results")
                worksheet = writer.sheets['Results']

                # Set column widths (adjust the widths as needed)
                for i, column in enumerate(df.columns):
                    column_len = max(df[column].astype(str).map(len).max(), len(column))
                    worksheet.set_column(i, i, column_len + 2)  # Add a bit of extra width

                # Conditional formatting - Change cell color based on value
                red_format = writer.book.add_format({'bg_color': '#FFC7CE', 'font_color': '#9C0006'})
                green_format = writer.book.add_format({'bg_color': '#C9FFC3', 'font_color': '#006100'})

                for row_num, row in df.iterrows():
                    if row['Flag'] == 'SAFE':
                        # Apply green formatting
                        worksheet.write(row_num + 1, df.columns.get_loc('Flag'), row['Flag'], green_format)
                        worksheet.write(row_num + 1, df.columns.get_loc('Rules Found'), row['Rules Found'], green_format)
                    elif row['Flag'] == 'THREAT':
                        # Apply red formatting
                        worksheet.write(row_num + 1, df.columns.get_loc('Flag'), row['Flag'], red_format)
                        worksheet.write(row_num + 1, df.columns.get_loc('Rules Found'), row['Rules Found'], red_format)

    def add_entry_to_table(self, entry):
        """
            Remarks: This method adds the current participant values into the metrics dataframe.
        """
        try:
            # retrieve the current amount of rows
            self.row_Count = self.tbResults.rowCount()
            self.tbResults.insertRow(self.row_Count)

            self.tbResults.setItem(self.row_Count, 0, QTableWidgetItem(str(entry["filename"])))
            self.tbResults.setItem(self.row_Count, 1, QTableWidgetItem(str(entry["flag"])))
            self.tbResults.setItem(self.row_Count, 2, QTableWidgetItem(str(entry["scan_date"])))
            self.tbResults.setItem(self.row_Count, 3, QTableWidgetItem(str(entry["scan_time"])))
            self.tbResults.setItem(self.row_Count, 4, QTableWidgetItem(str(entry["MD5"])))
            self.tbResults.setItem(self.row_Count, 5, QTableWidgetItem(str(entry["SHA256"])))
            self.tbResults.setItem(self.row_Count, 6, QTableWidgetItem(str(entry["location"])))
            self.tbResults.setItem(self.row_Count, 7, QTableWidgetItem(str(entry["rules_found"])))

            self.tbResults.resizeColumnsToContents()
            self.tbResults.setCurrentCell(self.row_Count, 0)
            self.tbResults.selectRow(self.row_Count)
        except TypeError as e:
            print(" The new item was NOT added into Table" + str(e))


def run_program():
    """
        Remarks: main runner.
    """
    app = QApplication([])
    app.setStyle('Fusion')

    global MAIN_WINDOW
    MAIN_WINDOW = ui_main()
    MAIN_WINDOW.show()

    sys.exit(app.exec())
