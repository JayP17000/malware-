"""
    Date created:   12/01/2023
    Date edited:    12/02/2023
    Sub-module:     core_logic.py
    Remarks:        program entry
"""
import os
import sys
import time
import yara
import src.frames.py.gui_main as mn
import src.frames.py.gui_results as rs

from PySide6.QtCore import QObject, Signal, QRunnable, QThreadPool
from PySide6.QtWidgets import QApplication, QMainWindow, QFileDialog, QLabel

# Global Variables
SELECTED_DIRECTORY = None
SELECTED_FILE = None
RULE_PATH = None


class ui_main(QMainWindow, mn.Ui_MainWindow):
    """
        Remarks: Main window frame declaration and definition.
    """

    def __init__(self):
        """
            Remarks: Class definition
        """

        super().__init__()

        self.setupUi(self)
        self.GUI_RESULTS = ui_results()
        self._connect_signals_to_slots()
        self._retrieve_yara_lib()
        self.threadpool = QThreadPool()

        self.lblStatusbar = QLabel("N/A")
        self.statusbar.addPermanentWidget(self.lblStatusbar)

    def _retrieve_yara_lib(self):
        """
            Remarks: Retrieves through dynamic path the yara rules stored in the program
        """
        global RULE_PATH
        current_path = os.path.abspath(__file__)
        dir_path = os.path.dirname(current_path)
        RULE_PATH = os.path.join(dir_path, 'yara_rules')
        print(str(RULE_PATH))

    def _connect_signals_to_slots(self):
        """
            Remarks: Connects all the interactive elements of the GUI to the methods of the class(es)
        """
        # Results Triggers
        # Button "Show" trigger event.
        self.btnShow.clicked.connect(self.GUI_RESULTS.display_results_window)

        # Button "Save" trigger event.

        # Directory Triggers
        # Button "Open" trigger event.
        self.btnOpen.clicked.connect(self._get_directory_path)
        self.actionOpen.triggered.connect(self._get_directory_path)

        # Scan Triggers
        # Button "Start" trigger event.
        self.btnStart.clicked.connect(self._start_scan)

    def _get_directory_path(self):
        self.update_lblStatusBar("Opening File...")
        """
            Remarks: Allows the user to open a directory.
        """
        # options = QFileDialog.options()
        global SELECTED_DIRECTORY
        SELECTED_DIRECTORY = QFileDialog.getExistingDirectory(
            None,
            "Select a Directory",
            "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        if SELECTED_DIRECTORY:
            # print("Current Directory: ", CURRENT_PATH)
            self.lblPathCont.setText(SELECTED_DIRECTORY)

    def _start_scan(self):
        """
            Remarks: Creates a new thread to run the yara scan on. Allowing the main program to keep running
        """
        # Define a new Search Worker
        worker = Search_Worker()

        # Connect the retrieved signals to the update methods
        worker.signals.update_current_file.connect(self._update_lblCurrentFileCont)
        worker.signals.update_current_directory.connect(self._update_lblCurrentDirectoryCont)
        worker.signals.update_scanned_files.connect(self._update_lblScannedFilesCont)
        worker.signals.update_scanned_directories.connect(self._update_lblScannedDirectoryCont)
        worker.signals.update_thread_count.connect(self._update_lblThreadCountCont)

        # Add the worker into the threadpool
        self.threadpool.start(worker)

        # Call worker's function with YARA rules path and selected directory
        worker.run_yara(RULE_PATH, SELECTED_DIRECTORY)

    def _update_lblCurrentFileCont(self, filename):
        self.lblCurrentFileCont.setText(str(filename))

    def _update_lblCurrentDirectoryCont(self, directory):
        self.lblCurrentDirectoryCont.setText(str(directory))

    def _update_lblScannedFilesCont(self, count):
        self.lblScannedFilesCont.setText(str(count))

    def _update_lblScannedDirectoryCont(self, count):
        self.lblScannedDirectoriesCont.setText(str(count))

    def _update_lblThreadCountCont(self, count):
        self.lblThreatsDetectedCont.setText(str(count))

    def update_lblStatusBar(self, string):
        self.lblStatusbar.setText(str(string))


class WorkerSignals(QObject):
    """
       Remarks: Defines the Signals to be transmitted between search worker and gui_main.
    """
    update_current_file = Signal(str)
    update_current_directory = Signal(str)
    update_scanned_files = Signal(int)
    update_scanned_directories = Signal(int)
    update_thread_count = Signal(int)


class Search_Worker(QRunnable):
    """
        Remarks: This class defines an object QRunnable to run alongside the main gui.
    """

    def __init__(self):
        super().__init__()
        self.signals = WorkerSignals()
        self._reset_counts()

    def run_yara(self, rules_path, target_directory):
        """
            Remarks: Handles the compilation of the yara rules, and the scanning for threads on a current directory
        """
        self._reset_counts()
        # List all files in the directory
        files = os.listdir(rules_path)

        # Filter .yar files from the list of files
        yara_files = [os.path.join(rules_path, file) for file in files if file.endswith('.yar')]

        # Compile each YARA file
        rules = {}
        for yara_file in yara_files:
            try:
                compiled_rule = yara.compile(yara_file)
                # Extracting the filename without extension as the rule name
                rule_name = os.path.splitext(os.path.basename(yara_file))[0]
                rules[rule_name] = compiled_rule
            except yara.Error as e:
                print(f"Error compiling {yara_file}: {e}")

        # Iterate through the folders and sub-folders of the target directory
        file_path = None

        for root, dirs, files in os.walk(target_directory):
            self.signals.update_current_directory.emit(str(root))
            self.directory_count += 1
            self.signals.update_scanned_directories.emit(self.directory_count)
            for filename in files:
                # Emit signal to display the current file
                # FIXME: Not the best implementation as it could lead to undefined states.
                QApplication.processEvents()
                self.signals.update_current_file.emit(str(filename))
                self.file_count += 1
                self.signals.update_scanned_files.emit(self.file_count)

                # Combine the file name with the root folder name
                file_path = os.path.join(root, filename)

                # Check if the item is a file (not a directory)
                if os.path.isfile(file_path):
                    with open(file_path, 'rb') as f:
                        file_content = f.read()

                    # Match the rules against the file content
                    for rule in rules.values():
                        matches = rule.match(data=file_content)

                        # Print the results
                        if matches:
                            # print(f"Malicious indicators found in {filename}:")
                            self.thread_count += 1
                            self.signals.update_thread_count.emit(self.thread_count)
                            for match in matches:
                                print(f"- Rule: {match.rule}")
                        else:
                            # print(f"No malicious indicators found in {filename}.")
                            pass

    def _reset_counts(self):
        """
            Remarks: Resets the file and the directory counters.
        """
        self.file_count = 0
        self.directory_count = 0
        self.thread_count = 0

        self.signals.update_scanned_files.emit(self.file_count)
        self.signals.update_scanned_directories.emit(self.directory_count)
        self.signals.update_thread_count.emit(self.thread_count)

    def stop(self):
        self.is_running = False


class ui_results(QMainWindow, rs.Ui_MainWindow):
    """
        Remarks: Class definition.
    """

    def __init__(self):
        """
            Remarks: Results window frame declaration and definition.
        """
        super().__init__()
        self.setupUi(self)

    # def connect_signals_to_slots(self):
    #     pass

    def display_results_window(self):
        """
            Remarks: Displays the result window.
        """
        self.show()


def run_program():
    """
        Remarks: main runner.
    """
    app = QApplication([])
    app.setStyle('Fusion')

    window = ui_main()
    window.show()

    sys.exit(app.exec())
